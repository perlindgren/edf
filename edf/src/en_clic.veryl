import Cfg::*;

module EdfNestedClic #() (
    i_clk         : input  clock    ,
    i_nrst        : input  reset    ,
    i_now         : input  DeadLine ,
    i_pend        : input  PendVec  ,
    i_pend_idx    : input  IntVecIdx,
    i_ret         : input  logic    ,
    o_dispatch    : output logic    ,
    o_dispatch_idx: output IntVecIdx,
) {
    var iv       : IntVec           ; // interrupt vector store
    var int_level: IntVecIdx        ; // number of stacked
    var int_stack: IntVecIdx [NrVec];
    var idle     : logic            ; // true indicates no interrupts running

    function normalize (
        int_vec: input IntVec  ,
        now    : input DeadLine,
    ) -> RelDeadLines {
        var rel_dl: RelDeadLines;

        for i: u32 in 0..NrVec {
            if (int_vec[i].pend & int_vec[i].enable) | (int_stack[int_level] == i as IntVecIdx & !idle) {
                // either pended and enabled OR already running
                rel_dl[i] = int_vec[i].abs_dl - now;
            } else {
                // MAX_DEADLINE indicate a task not being part of arbitration
                rel_dl[i] = MAX_DEADLINE;
            }
        }
        return rel_dl;
    }

    function min (
        arr        : input RelDeadLines,
        range_start: input IntVecIdx   ,
        range_end  : input IntVecIdx   ,
    ) -> TreeItem {
        if (range_end - range_start) >= 2 {
            let middle: IntVecIdx = range_start + ((range_end - range_start) >> 1);
            let left  : TreeItem  = min(arr, range_start, middle);
            let right : TreeItem  = min(arr, middle + 1, range_end);
            if (left.value <: right.value) {
                return left;
            } else {
                return right;
            }
        } else if ((range_end - range_start) == 1) {
            if ((arr[range_start]) <: arr[range_end]) {
                var item      : TreeItem;
                item.value = arr[range_start];
                item.idx   = range_start;
                return item;
            } else {
                var item      : TreeItem;
                item.value = arr[range_end];
                item.idx   = range_end;
                return item;
            }
        } else {
            var item      : TreeItem;
            item.value = arr[range_start];
            item.idx   = range_start;
            return item;
        }
    }

    always_ff (i_clk, i_nrst) {
        if_reset {
            for i: u32 in 0..NrVec {
                iv[i].pend     = 0; // clear interrupt vector pending/enable bits
                iv[i].enable   = 0;
                o_dispatch     = 0; // clear dispatch outputs
                o_dispatch_idx = 0;
                int_level      = 0;
                idle           = 1; // initially idle
                int_stack[i]   = (NrVec - 1) as IntVecIdx;
            }
        } else {
            // clear running status of returned task
            var next_idle     : logic    ;
            var next_int_level: IntVecIdx;

            next_idle      = idle;
            next_int_level = int_level;

            if i_ret {
                if int_level == 0 {
                    next_idle = 1;
                } else {
                    next_int_level -= 1;
                }
            }

            // notice one cycle latency on (external) pend
            for i: u32 in 0..NrVec {
                if i_pend[i] & !iv[i].pend {
                    iv[i].pend   = 1;
                    iv[i].abs_dl = i_now + iv[i].rel_dl;
                }
            }

            let rel_dl: RelDeadLines = normalize(iv, i_now);

            let min_ti: TreeItem = min(rel_dl, 0, (NrVec - 1) as IntVecIdx);

            // we check that it is not infinite in the future, and not already running
            if min_ti.value != MAX_DEADLINE & ((int_stack[next_int_level] != min_ti.idx) | next_idle) {
                iv[min_ti.idx].pend = 0;
                o_dispatch          = 1;
                if next_idle {
                    next_int_level = 0;
                    next_idle      = 0;
                    int_stack[0]   = min_ti.idx;
                } else {
                    $display                 ("--- here ---");
                    next_int_level            += 1;
                    int_stack[next_int_level] =  min_ti.idx;
                }
            } else {
                o_dispatch = 0;
            }
            idle           = next_idle;
            int_level      = next_int_level;
            o_dispatch_idx = min_ti.idx;
        }
    }
}
