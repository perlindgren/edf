import Types::*;

module EdfNestedClic #() (
    i_clk         : input  clock    ,
    i_nrst        : input  reset    ,
    i_now         : input  DeadLine ,
    i_pend        : input  PendVec  ,
    i_pend_idx    : input  IntVecIdx,
    i_ret         : input  logic    ,
    i_ret_idx     : input  IntVecIdx,
    o_dispatch    : output logic    ,
    o_dispatch_idx: output IntVecIdx,
) {
    var iv: IntVec; // iv will be assigned on reset

    function normalize (
        int_vec: input IntVec  ,
        now    : input DeadLine,
    ) -> RelDeadLines {
        var rel_dl: RelDeadLines;

        for i: u32 in 0..NrVec {
            if (int_vec[i].pend & int_vec[i].enable) | int_vec[i].running {
                // either pended and enabled OR already running
                rel_dl[i] = int_vec[i].abs_dl - now;
            } else {
                // MAX_DEADLINE indicate a task not being part of arbitration
                rel_dl[i] = MAX_DEADLINE;
            }
        }
        return rel_dl;
    }

    function min (
        arr        : input RelDeadLines,
        range_start: input IntVecIdx   ,
        range_end  : input IntVecIdx   ,
    ) -> IntVecIdx {
        if (range_end - range_start) >= 2 {
            let middle: IntVecIdx = range_start + ((range_end - range_start) >> 1);
            let left  : IntVecIdx  = min(arr, range_start, middle);
            let right : IntVecIdx  = min(arr, middle + 1, range_end);
            if (arr[left] <: arr[right]) {
                return left;
            } else {
                return right;
            }
        } else if ((range_end - range_start) == 1) {
            if ((arr[range_start]) <: arr[range_end]) {
                return range_start;
            } else {
                return range_end;
            }
        } else {
            return range_start;
        }
    }

    always_ff (i_clk, i_nrst) {
        if_reset {
            for i: u32 in 0..NrVec {
                iv[i].pend     = 0; // clear interrupt vector pending/enable bits
                iv[i].enable   = 0;
                iv[i].running  = 0;
                o_dispatch     = 0; // clear dispatch outputs
                o_dispatch_idx = 0;
            }
        } else {
            // clear running status of returned task
            if i_ret {
                iv[i_ret_idx].running = 0;
            }

            for i: u32 in 0..NrVec {
                if i_pend[i] & !iv[i].pend {
                    iv[i].pend   = 1;
                    iv[i].abs_dl = i_now + iv[i].rel_dl;
                }
            }

            let rel_dl: RelDeadLines = normalize(iv, i_now);

            let min_idx: IntVecIdx = min(rel_dl, 0, (NrVec - 1) as IntVecIdx);

            // we check that it is not infinite in the future, and not already running
            if rel_dl[min_idx] != MAX_DEADLINE & !iv[min_idx].running {
                iv[min_idx].pend    = 0;
                iv[min_idx].running = 1;
                o_dispatch             = 1;
            } else {
                o_dispatch = 0;
            }
            o_dispatch_idx = min_idx;
        }
    }
}
