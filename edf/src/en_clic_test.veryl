#[test(en_clic)]
embed (inline) sv{{{

    module test;
        import edf_Cfg::*;

        logic i_clk; 
        logic i_nrst;
        DeadLine i_now;
        PendVec i_pend;
        IntVecIdx i_pend_idx;
        logic i_ret;
        
        logic o_dispatch;
        IntVecIdx o_dispatch_idx;

        DeadLine tasks[NrVec];

        int now;

        edf_EdfNestedClic dut (
            .i_clk,
            .i_nrst,
            .i_now,
            .i_pend,
            .i_pend_idx,
            .i_ret,
            .o_dispatch,
            .o_dispatch_idx
        );

        task tick (int x);
            for (int i = 0; i < x; i++) begin
                i_clk = 0;
                # 5;
                i_clk = 1;
                # 5;
                now = now + 1;
                i_now = now[7:0];
                // we clear pend and i_ret by default
                i_pend = 0;
                i_ret = 0;

                // count down executing task
                if (!dut.idle) begin
                    tasks[o_dispatch_idx]--;
                    if (tasks[o_dispatch_idx] == 0) begin
                        i_ret = 1;
                    end 
                end
                
            end

	    endtask

        function void pend(IntVecIdx i, DeadLine dl);
            i_pend |= 1 << i;
            tasks[i] = dl;
	    endfunction

 
        initial begin
           
            now = 0;
            i_nrst = 0; // reset

            tick(1);
            i_nrst = 1; // after reset

            dut.iv[0].enable = 1; // enable interrupt
            dut.iv[1].enable = 1; // enable interrupt
            dut.iv[2].enable = 1; // enable interrupt
            dut.iv[0].rel_dl = 10;
            dut.iv[1].rel_dl = 50;
            dut.iv[2].rel_dl = 100;

            i_ret = 0;

            pend(0, 5);
            pend(1, 20);
            pend(2, 50); // task 0 starts
            
            tick(15);
            pend(0, 5);
            

            tick(100);
            // ret(0); // task 0 done, task 1 to execute
            
            // tick(10);
            // ret(1); // task 1 done, task 2 starts to execute

            // tick(20);

            // pend(1); // task 1 to execute, preempts 2

            // tick(5);

            // pend(0); // task 0 to execute, preempts 1

            // tick(5);

            // ret(0); // task 0 done, task 1 cont.

            // tick(10);
            // ret(1); // task 1 done, task 2 cont.

            // tick(20);

            // ret(2);            

            // tick(10);

        end
    endmodule
}}}
